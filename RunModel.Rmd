---
title: "Foraging Model"
author: "Ben Weinstein"
date: "`r Sys.time()`"
output: 
  html_document:
    toc: true
    number_sections: true
    theme: united
---

#Abstract

Foraging behavior shapes animal health through the balance of the resources expended to obtain nutrients and the energetic rewards of captured resources. The health of individuals will influence reproductive success, fitness and ultimately population viability. Despite the key role of individual health in evolutionary ecology, it can be challenging to connect foraging behavior and energetics in free living marine organisms. Combining data on foraging strategies, feeding behavior and physiology, we estimate body mass for humpback whales as they forage near the Antarctic Peninsula. Humpback whales require extreme energetic storage to facilitate the yearly migration between austral foraging areas to equatorial breeding grounds. Based on tagged individuals, we model the foraging effort, duration and energetics of animals throughout the austral season. We then connect these measurements to studies of whale feeding physiology and biomechanics. While predictive modeling of individual behavior will be naturally complex, we utilize hierarchical Bayesian models to propagate uncertainty throughout the model. By testing a variety of model assumptions surrounding energetics and foraging rate, we can understand the sensitivity of our predictions to parameter bounds. Our model forms the basis for field tests of animal body condition and further exploration of individual behavior and animal health. Future work combining the environmental impacts of changing ocean conditions on foraging success will inform conservation strategies in a changing marine ecosystem.


# Foraging Model

The proportion of time an animal is in a feeding behavioral state.

(@eq1)

*Process Model*

$$Y_{i,t+1} \sim Multivariate Normal(d_{i,t},σ)$$

$$d_{i,t}= Y_{i,t} + γ_{s_{i,g,t}}*T_{i,g,t}*( Y_{i,g,t}- Y_{i,g,t-1} )$$

$$
\begin{matrix}
  \alpha_{i,1,1} & 1-\alpha_{i,1,1} \\
  \alpha_{i,2,1} & 1-\alpha_{i,2,1} \\
\end{matrix}
$$
$$logit(\phi_{traveling}) = \alpha_{Behavior_{t-1}}$$
The behavior at time t of individual i on track g is a discrete draw.
$$S_{i,g,t} \sim Cat(\phi_{traveling},\phi_{foraging})$$

Dive information is a mixture model based on behavior (S)

$\text{Average dive depth}(\psi)$
$$ \psi \sim Normal(dive_{\mu_S},dive_{\tau_S})$$

```{r,echo=F,warning=F,message=F}
library(tidyr)
library(ggplot2)
library(maptools)
library(raster)
library(data.table)

library(dplyr)
library(stringr)
library(chron)
library(R2jags)
library(boot)
library(knitr)
library(truncnorm)

newModel=T

opts_chunk$set(echo=F,warning=F,message=F,fig.width=11)

mytheme<-theme(axis.text.x=element_blank(),axis.ticks.x=element_blank(),axis.text.y=element_blank(),axis.ticks.y=element_blank(),axis.title.x=element_blank(),axis.title.y=element_blank(),panel.grid=element_blank())
```

```{r}

if(!newModel){
  load("/Users/Ben/Dropbox/Whales/Dive/WhalePhys.RData")
  newModel=F
}

#get dive data

f<-list.files("/Users/Ben/Dropbox/Whales/Data/Humpback",pattern="Locations",full.names=T,recursive = T)

#just grab five individuals for now
gdat<-lapply(f,function(x) read.csv(x,stringsAsFactors=F))
gdat<-lapply(gdat,function(x){
  x$Quality<-as.character(x$Quality)
  return(x)
}) 

gdat<-bind_rows(gdat)

#timestamp
gdat$Date<-as.POSIXct(gdat$Date,format="%H:%M:%S %d-%b-%Y",tz="Etc/GMT+3")

#get data files
f<-list.files("/Users/Ben/Dropbox/Whales/Data/Humpback/",pattern="Behavior",full.names=T,recursive = T)

#test data set  [0:2]
dat<-bind_rows(lapply(f,read.csv))
dat$GMTtime<-as.POSIXct(dat$End,format="%H:%M:%S %d-%b-%Y",tz="Etc/GMT+3")
  
#local time
dat$timestamp<-as.POSIXct(format(dat$GMTtime,tz="Etc/GMT+3"))

dat$Month<-months(dat$timestamp)
dat$Month<-factor(dat$Month,levels=month.name)
dat$Hour<-strftime(dat$timestamp,format="%H")
dat$Year<-years(dat$timestamp)
  
#create unique messages
indices<-which(dat$What=="Message")
counter=1
dat$ID<-NA
for (x in 1:(length(indices)-1)){
dat[indices[x]:indices[x+1],"ID"]<-counter
counter=counter+1
}

dive<-dat %>% filter(What=="Dive")%>% dplyr::select(Animal=Ptt,timestamp,Hour,Month,Year, ID,Start,DepthMax,DepthMin,DurationMax,DurationMin)
dive<-dive[!is.na(dive$Month),]
    
#remove duplicate data
dive<-dive %>% arrange(Animal,timestamp) 
dive<-dive[!duplicated(dive),]
```

Dive profiles per indidivuals

```{r}
ggplot(dive,aes(x=timestamp,y=-DepthMax)) + geom_point(size=0.1) + geom_line(size=0.1) + facet_wrap(~Animal,scales="free") + theme_bw()
ggsave("Figures/perindividual.jpeg",height=6,width=12)
```


```{r}
##Merge with geographic data and format for JAGS
messages<-dat %>% filter(dat$What=="Message")
messages$timestamp<-as.POSIXct(messages$End,format="%H:%M:%S %d-%b-%Y",tz="Etc/GMT+3")

#look up the time interval that best fits
setDT(gdat)            ## convert to data.table by reference
setDT(messages)            ## same

setkey(messages, Ptt,timestamp)    ## set the column to perform the join on
setkey(gdat,Ptt, Date)    ## same as above

ans = gdat[messages, roll=Inf] ## perform rolling join
ans<-as.data.frame(ans)

message_join<-ans %>% dplyr::select(Date,Animal=Ptt,Date,Quality,Latitude,Longitude,ID)

mdat<-merge(dat,message_join,by="ID")
mdat<-mdat %>% filter(What=="Dive")

#The maxiumum dive depth based on the geographic message
mdat<-mdat %>% dplyr::select(ID,Animal,Latitude,Longitude,timestamp,Date,Month,Hour,Year,DepthMax,DurationMax,DurationMin,Quality) 

mdat<-mdat %>% group_by(ID,Animal) %>% slice(which.max(DepthMax)) %>% arrange(Animal,timestamp) %>% filter(!is.na(Latitude))

#crop by extent
d<-SpatialPointsDataFrame(cbind(mdat$Longitude,mdat$Latitude),data=data.frame(mdat),proj4string=CRS("+proj=longlat +datum=WGS84"))

cropoly<-readShapePoly("Data/CutPolygon.shp",proj4string=CRS("+proj=longlat +datum=WGS84"))

b<-d[!is.na(d %over% cropoly)[,2],]

mdat<-b@data

#set max depth to km
mdat$DepthMax<-mdat$DepthMax/1000

#view data
ggplot(data=mdat)+geom_path(aes(x=Longitude, y=Latitude,group=Animal),size=.5) + geom_point(aes(x=Longitude, y=Latitude,col=DepthMax))+ borders(fill="grey90") + coord_cartesian(ylim = range(mdat$Latitude),xlim=range(mdat$Longitude)) + theme_bw() + mytheme + scale_color_continuous(low="blue",high="red") + labs(col="Max Dive Depth (km)")
ggsave("Figures/Map.svg")
ggsave("Figures/Map.png")

##Time is the beginning of the first point.
step_length=6

sxy<-split(mdat,mdat$Animal)

#time diff function
timed<-function(d,step_length){
  d$j[1]<-0
  for (x in 2:nrow(d)){
    d$j[x]<-as.numeric(difftime(as.POSIXct(d$timestamp[x]),as.POSIXct(d$timestamp[x-1]),units="mins"))/(step_length*60)
  }
  
  #Split out track endings
  ends<-c(1,which(d$j>1),nrow(d))

  for(w in 2:length(ends)){
    d[ends[w-1]:ends[w],"Track"]<-w-1
  }
  
  #remove tracks that are shorter than three days
  track_time<-d %>% group_by(Track) %>% summarize(mt=difftime(max(as.POSIXct(timestamp)),min(as.POSIXct(timestamp)),units="hours")) %>% filter(mt>=24) %>% .$Track
  
  d<-d[d$Track %in% track_time,]
  
  #renumber the tracks
  d$Track<-as.numeric(as.factor(d$Track))
  return(d)
  }

sxy<-lapply(sxy,timed,step_length=step_length)

#Format matrices for jags
mdat<-bind_rows(sxy)

sxy<-split(mdat,list(mdat$Animal,mdat$Track),drop=TRUE)

sxy<-lapply(sxy,function(x){
#How many observations in each step length segment
x$step<-as.numeric(cut(as.POSIXct(x$timestamp),paste(step_length,"hours")))
return(x)
})

mdat<-bind_rows(sxy)

###################################################
#filter by two whales for the moment
#mdat<-mdat %>% filter(Animal %in% c("131127","131136"))
#mdat<-mdat %>% filter(Animal %in% c("131127"))
####################################################

#refactor animal
mdat$Animal<-as.numeric(as.factor(mdat$Animal))

##Split into format for JAGS

#total number of steps per track/animal
steps_all<-mdat %>% group_by(Animal,Track) %>% summarize(n=length(unique(step)))

# give each step a label
mdat<-mdat %>% group_by(Animal,Track,step) %>% mutate(jStep=1:n())

#Cast time array
j<-reshape2::acast(mdat,Animal~Track~step~jStep,value.var="j")

#how many observations per individual in each step
mdat$step<-factor(mdat$step,levels=1:max(steps_all$n))
idx<-reshape2::melt(table(mdat$Animal,mdat$Track,mdat$step))
colnames(idx)<-c("Animal","Track","step","jStep")
idx<-reshape2::acast(data=idx,Animal~Track~step)

#Individuals
ind=length(unique(mdat$Animal))

#tracks per indivudal
tracks<-mdat %>% group_by(Animal) %>% summarize(tracks=length(unique(Track))) %>% .$tracks

#steps per track
steps<-reshape2::acast(steps_all,Animal~Track,value.var="n")

#obs array
obs<-reshape2::melt(mdat,measure.vars=c("Longitude","Latitude"))
obs<-reshape2::acast(obs,Animal~Track~step~jStep~variable,fun.aggregate = mean)

#argos class array
mdat$argos.lc<-factor(mdat$Quality,levels=c(3,2,1,0,"A","B"))
mdat$numargos<-as.numeric(mdat$argos.lc)
obs_class<-reshape2::acast(mdat,Animal~Track~step~jStep,value.var="numargos",fun.aggregate = min)

obs_class[!is.finite(obs_class)]<-NA

#average dive depth array
maxdive<-reshape2::acast(mdat,Animal~Track~step,value.var="DepthMax",fun.aggregate = mean)

#fill the empty values
maxdive[!is.finite(maxdive)]<-NA
```


```{r,child="Bayesian/Diving.R",eval=T}
```

```{r,eval=T}
#source jags file
source("Bayesian/Diving.R")

#prior cov shape
R <- diag(c(1,1))
data=list(dive=maxdive,argos=obs,steps=steps,R=R,ind=ind,j=j,idx=idx,tracks=tracks,argos_class=obs_class)

#paramters to track
pt<-c("alpha","beta","state")

if(newModel){
  system.time(diving<-jags.parallel(model.file = "Bayesian/Diving.jags",data=data,n.chains=2,parameters.to.save=pt,n.iter=50000,n.burnin=49500,n.thin=2,DIC=FALSE))
  }

```

##Chains
```{r,eval=T}
#bind chains
pc_dive<-reshape2::melt(diving$BUGSoutput$sims.array)
colnames(pc_dive)<-c("Draw","chain","par","value")

#extract parameter name
pc_dive$parameter<-data.frame(str_match(pc_dive$par,"(\\w+)"))[,-1]

#Extract index
splitpc<-split(pc_dive,pc_dive$parameter)

#single index
splitpc[c("alpha")]<-lapply(splitpc[c("alpha")],function(x){
    sv<-data.frame(str_match(x$par,"(\\w+)\\[(\\d+)]"))[,3]
    pc<-data.frame(x,Behavior=sv)
    return(pc)
}) 

#3 index
splitpc[c("state")]<-lapply(splitpc[c("state")],function(x){
    sv<-data.frame(str_match(x$par,"(\\w+)\\[(\\d+),(\\d+),(\\d+)"))[,3:5]
    colnames(sv)<-c("Animal","Track","step")
    pc<-data.frame(x,sv)
    return(pc)
}) 

#bind all matrices back together
pc_dive<-bind_rows(splitpc)
rm(splitpc)

ggplot(pc_dive[!pc_dive$parameter %in% c("state"),],aes(x=Draw,y=value,col=as.factor(chain))) + geom_line() + facet_wrap(~par,scales="free") + theme_bw() + labs(col="Chain")
```

Effect of dive depth on foraging state

```{r}
beta<-pc_dive %>% filter(parameter=="beta")

divecov<-bind_rows(lapply(beta$value,function(x){
  pForaging<-1-inv.logit(x * mdat$DepthMax)
  divecov<-data.frame(DepthMax=mdat$DepthMax,p=pForaging)
}))

divecov<-divecov %>% group_by(DepthMax) %>% summarise(mean=mean(p),upper=quantile(p,0.95),lower=quantile(p,0.05))

ggplot(divecov,aes(x=DepthMax*1000,y=mean)) + geom_ribbon(aes(ymax=upper,ymin=lower),alpha=0.5)+ geom_line(linetype="dashed",col="red") +  theme_bw() + labs(x="Dive Depth (m)",y="Probability of Foraging")
```

## Temporal autocorrelation in foraging 

```{r}
alpha<-pc_dive %>% filter(parameter=="alpha")
alpha$Behavior<-as.character(alpha$Behavior)
alpha$Behavior[alpha$Behavior=="1"]<-"Traveling->Traveling"
alpha$Behavior[alpha$Behavior=="2"]<-"Foraging->Traveling"

ggplot(alpha,aes(x=value)) + geom_histogram() + facet_wrap(~Behavior) + labs(x="Probability of Transition")

#label previous and prediction state, treat traveling as a success and foraging as a failure in a binomial trial
alpha[alpha$Behavior=="Traveling->Traveling","Previous_State"]<-1
alpha[alpha$Behavior=="Foraging->Traveling","Previous_State"]<-0
write.csv(alpha,"Data/Alpha.csv",row.names=F)
```

### Time foraging as a function of time

* 12 time step

```{r}
foraging_time<-function(alpha,draws,step){
  states<-c()
  
  #initial state is traveling
  states[1]<-(1)
  
  for(x in 2:draws){
    
    #probability of staying, or switching, to traveling state
    travel_prob=alpha %>% filter(Previous_State==states[x-1]) %>% sample_n(1) %>% .$value
    
    #pick next state
    states[x]<-rbinom(1,1,travel_prob)
  }
  
  #total hours of foraging
  total_foraging<-sum(states==0) * step
return(total_foraging)
}

states<-foraging_time(alpha=alpha,draw=20,step=12)

```

# Temporal Variation in Dive Behavior

```{r}

#Take the most common estimate of behavior
Mode <- function(x) {
  ux <- unique(x)
  ux[which.max(tabulate(match(x, ux)))]
}

#Combine posterior summary
mdat$Animal<-as.factor(mdat$Animal)
mdat$Track<-as.factor(mdat$Track)
mdat$step<-as.factor(mdat$step)

state_est<-pc_dive %>% group_by(Animal,Track,step) %>% filter(parameter=="state") %>% summarize(Behavior=Mode(value)) %>% inner_join(mdat)

state_est[state_est$Behavior==1,"Behavior"]<-"Traveling"
state_est[state_est$Behavior==2,"Behavior"]<-"Foraging"
```

```{r}
ggplot(state_est,aes(x=timestamp,y=-DepthMax,col=Behavior)) + geom_point() + geom_line(size=0.25,aes(group=1)) + facet_wrap(~Animal,scales="free") + theme_bw()
ggsave("Figures/TemporalBehavior.svg")
ggsave("Figures/TemporalBehavior.jpeg",height=8,width=12)

```

## Diel

```{r}
ggplot(data=state_est) + geom_boxplot(aes(x=Hour,y=DepthMax,fill=Behavior)) + ylab("Maximum Dive Depth (km)")
ggsave("Figures/Diel.svg")
ggsave("Figures/Diel.png",height=5,width=8,unit="in")

ggplot(data=state_est) + geom_boxplot(aes(x=Hour,y=DepthMax,fill=Behavior)) + ylab("Maximum Dive Depth (km)") + facet_wrap(~Month)
ggsave("Figures/DielbyMonth.svg")
ggsave("Figures/DielbyMonth.png",height=5,width=10,unit="in")
```

## Month
```{r}
ggplot(data=state_est) + geom_boxplot(aes(x=Month,y=DepthMax,fill=Behavior)) + ylab("Maximum Dive Depth (km)")
ggsave("Figures/Month.svg")
ggsave("Figures/Month.png",height=5,width=8,unit="in")
```


# Comparison with 2d movement model

* Movement model

```{r,eval=T}
#source jags file
source("Bayesian/Foraging.R")

#prior cov shape
R <- diag(c(1,1))
data=list(argos=obs,steps=steps,R=R,ind=ind,j=j,idx=idx,tracks=tracks,argos_class=obs_class)

#paramters to track
pt<-c("alpha","state")

if(newModel){
  system.time(foraging<-jags.parallel(model.file = "Bayesian/Foraging.jags",data=data,n.chains=2,parameters.to.save=pt,n.iter=50000,n.burnin=49500,n.thin=2,DIC=FALSE))
  }

```

##Chains

```{r,eval=T}
#bind chains
pc_dive2d<-reshape2::melt(foraging$BUGSoutput$sims.array)
colnames(pc_dive2d)<-c("Draw","chain","par","value")

#extract parameter name
pc_dive2d$parameter<-data.frame(str_match(pc_dive2d$par,"(\\w+)"))[,-1]

#Extract index
splitpc<-split(pc_dive2d,pc_dive2d$parameter)

#single index
splitpc[c("alpha")]<-lapply(splitpc[c("alpha")],function(x){
    sv<-data.frame(str_match(x$par,"(\\w+)\\[(\\d+)]"))[,3]
    pc<-data.frame(x,Behavior=sv)
    return(pc)
}) 

#3 index
splitpc[c("state")]<-lapply(splitpc[c("state")],function(x){
    sv<-data.frame(str_match(x$par,"(\\w+)\\[(\\d+),(\\d+),(\\d+)"))[,3:5]
    colnames(sv)<-c("Animal","Track","step")
    pc<-data.frame(x,sv)
    return(pc)
}) 

#bind all matrices back together
pc_dive2d<-bind_rows(splitpc)
rm(splitpc)

ggplot(pc_dive2d[!pc_dive2d$parameter %in% c("state"),],aes(x=Draw,y=value,col=as.factor(chain))) + geom_line() + facet_wrap(~par,scales="free")
```

```{r}

#Take the most common estimate of behavior
Mode <- function(x) {
  ux <- unique(x)
  ux[which.max(tabulate(match(x, ux)))]
}

#Combine posterior summary
mdat$Animal<-as.factor(mdat$Animal)
mdat$Track<-as.factor(mdat$Track)
mdat$step<-as.factor(mdat$step)

state_est2d<-pc_dive2d %>% group_by(Animal,Track,step) %>% filter(parameter=="state") %>% summarize(Behavior =Mode(value)) %>% inner_join(mdat)

state_est2d[state_est2d$Behavior==1,"Behavior"]<-"Traveling"
state_est2d[state_est2d$Behavior==2,"Behavior"]<-"Foraging"

state_est$Model<-"2D"
state_est2d$Model<-"3D"

allmodels<-bind_rows(state_est,state_est2d)

```

```{r}
ggplot(data=allmodels)+geom_path(aes(x=Longitude, y=Latitude,group=Animal),size=.5) + geom_point(aes(x=Longitude, y=Latitude,col=Behavior),size=0.5)+ borders(fill="grey90") + coord_cartesian(ylim = range(mdat$Latitude),xlim=range(mdat$Longitude)) + theme_bw() + mytheme  + facet_wrap(~Model)
```

Where does the 3d predict foraging that the 2d misses?

```{r}
allmodels<-spread(allmodels,Model,Behavior)
allmodels$Mismatch<-F
allmodels[allmodels$`2D`=="Traveling" & allmodels$`3D`=="Foraging","Mismatch"]<-TRUE

ggplot(allmodels)+geom_path(aes(x=Longitude, y=Latitude,group=Animal),size=.25) + geom_point(aes(x=Longitude, y=Latitude,col=Mismatch))+ borders(fill="grey90") + coord_cartesian(ylim = range(mdat$Latitude),xlim=range(mdat$Longitude)) + theme_bw() + mytheme + scale_color_manual(values=c("Black","Red"))
```


Where does the 2d predict foraging that the 3d refines?

```{r}
allmodels$Mismatch<-F
allmodels[allmodels$`2D`=="Foraging" & allmodels$`3D`=="Traveling","Mismatch"]<-TRUE

ggplot(allmodels)+geom_path(aes(x=Longitude, y=Latitude,group=Animal),size=.25) + geom_point(aes(x=Longitude, y=Latitude,col=Mismatch))+ borders(fill="grey90") + coord_cartesian(ylim = range(mdat$Latitude),xlim=range(mdat$Longitude)) + theme_bw() + mytheme + scale_color_manual(values=c("Black","Red"))
```


* Get spatial distribution

```{r,eval=FALSE}
#time in each cell function
  timecell<-function(j){
    
    rlej<-rle(x=diff(j$Index))
    position<-c(1,cumsum(rlej$lengths))
    timestack<-c()
    
    #if only one position
    if(length(position)==1){
      timestack[1]<-0
      
    } else {
      
      #time difference between first and last point in the cell
        for(x in 2:length(position)){
          timed<-j[position[x-1]:position[x],]
          timestack[x-1]<-difftime(max(timed$timestamp),min(timed$timestamp),units="days")
      }
    }
  
    out<-data.frame(Sum=sum(timestack))
    return(out)
  }
  
restime<-function(mdat){
  #raster
  r<-raster(extent(d)*c(1.1,1.1),nrow=100,ncol=100)
  
  #res(r)<-0.25
  #put cellindex number
  r[]<-1:ncell(r)
  
  sxy<-split(mdat,mdat$Animal)
  sxy<-lapply(sxy,function(x) {x$Index<-1:nrow(x); return(x)})
  
  #loop through all animals
  sptracks<-lapply(sxy,function(x){
    k<-SpatialPointsDataFrame(cbind(x$x,x$y),data=x,proj4string=CRS("+proj=longlat +datum=WGS84"))
    
    #get the cells that points are in
    k$cellvalue<-raster::extract(x=r,y=k)
    
    #for each cell value, perform time function
    sptrack<-as.data.frame(k) %>% group_by(Animal,cellvalue) %>% do(timecell(.))
    return(sptrack)}
  )
  
  sptracks<-rbind_all(sptracks)
  
  #get sum across animals
  cellvals<-sptracks %>% group_by(cellvalue) %>% summarize(Sum=sum(Sum))
  
  #is there a better way to loop through?
  r[]<-NA
  for(x in 1:nrow(cellvals)){
    r[cellvals$cellvalue[x]]<-cellvals$Sum[x]
  }
  return(r)
}

plot(restime(mdat))

#split tracks by month data, just get foraging data
#md<-split(mdat[mdat$bstate %in% "Area-restricted Search",],mdat[mdat$bstate %in% "Area-restricted Search","Month"],drop=T)
#md<-split(mdat,mdat$Month,drop=T)

r<-stack(lapply(mdat,restime))

plot(r)

#turn to 
f<-melt(data.frame(rasterToPoints(r)),id.vars=c("Latitude","Longitude"))

#remove NA's
f<-f %>% filter(!is.na(value))

ggplot() + geom_tile(data=f,aes(x=Longitude,y=Latitude,fill=value))  + scale_fill_continuous(low="blue",high="red") + labs(fill="Days")  + facet_wrap(~variable,nrow=3)  + theme(axis.text.x=element_blank(),axis.text.y=element_blank(),axis.ticks.x=element_blank(),axis.ticks.y=element_blank()) + labs(x="",y="") +  borders(fill="grey70",size=0.5) + coord_cartesian(ylim = c(-69,-62),xlim=c(-55,-72)) + theme_bw() + mytheme
ggsave("Figures/ResidencyMap.jpg",height=9,width=6,dpi=300)
```


```{r}
save.image("/Users/Ben/Dropbox/Whales/Dive/WhalePhys.RData")
```