---
title: "Foraging Model"
author: "Ben Weinstein"
date: "`r Sys.time()`"
output: 
  html_document:
    toc: true
    number_sections: true
    theme: united
---

#Abstract

Foraging behavior shapes animal health through the balance of the resources expended to obtain nutrients and the energetic rewards of captured resources. The health of individuals will influence reproductive success, fitness and ultimately population viability. Despite the key role of individual health in evolutionary ecology, it can be challenging to connect foraging behavior and energetics in free living marine organisms. Combining data on foraging strategies, feeding behavior and physiology, we estimate body mass for humpback whales as they forage near the Antarctic Peninsula. Humpback whales require extreme energetic storage to facilitate the yearly migration between austral foraging areas to equatorial breeding grounds. Based on tagged individuals, we model the foraging effort, duration and energetics of animals throughout the austral season. We then connect these measurements to studies of whale feeding physiology and biomechanics. While predictive modeling of individual behavior will be naturally complex, we utilize hierarchical Bayesian models to propagate uncertainty throughout the model. By testing a variety of model assumptions surrounding energetics and foraging rate, we can understand the sensitivity of our predictions to parameter bounds. Our model forms the basis for field tests of animal body condition and further exploration of individual behavior and animal health. Future work combining the environmental impacts of changing ocean conditions on foraging success will inform conservation strategies in a changing marine ecosystem.


##Time Feeding

The proportion of time an animal is in a feeding behavioral state.

(@eq1)


*Process Model*

$$Y_{i,t+1} \sim Multivariate Normal(d_{i,t},σ)$$

$$d_{i,t}= Y_{i,t} + γ_(s_(i,g,t) )*T_(i,g,t)*( Y_(i,g,t)- Y_(i,g,t-1) )$$

$$
\begin{matrix}
  \alpha_{i,1,1} & 1-\alpha_{i,1,1} \\
  \alpha_{i,2,1} & 1-\alpha_{i,2,1} \\
\end{matrix}
$$


$$logit(\phi_{traveling}) = \alpha_{Behavior_{t-1}}$$
The behavior at time t of individual i on track g is a discrete draw.
$$S_{i,g,t} \sim Cat(\phi_{traveling},\phi_{foraging})$$

Dive information is a mixture model based on behavior (S)

$Average dive depth (\psi)$
$$ \psi \sim Normal(dive_{\mu_S},dive_{\tau_S})$$

$\text{Average number of dives }(\omega)$
$$ \omega \sim Poisson(\lambda_S)$$

```{r,echo=F,warning=F,message=F}
library(tidyr)
library(ggplot2)
library(maptools)
library(raster)
library(data.table)

library(dplyr)
library(stringr)
library(chron)
library(R2jags)
library(knitr)


newModel=F

opts_chunk$set(echo=F,warning=F,message=F,fig.width=11)

mytheme<-theme(axis.text.x=element_blank(),axis.ticks.x=element_blank(),axis.text.y=element_blank(),axis.ticks.y=element_blank(),axis.title.x=element_blank(),axis.title.y=element_blank(),panel.grid=element_blank())
```

```{r}

if(!newModel){
  load("WhalePhys.RData")
  newModel=F
}

#get dive data

f<-list.files("C:/Users/Ben/Dropbox/Whales/Data/Humpback",pattern="Locations",full.names=T,recursive = T)

#just grab five individuals for now
gdat<-lapply(f,function(x) read.csv(x,stringsAsFactors=F))
gdat<-lapply(gdat,function(x){
  x$Quality<-as.character(x$Quality)
  return(x)
}) 

gdat<-bind_rows(gdat)

#timestamp
gdat$Date<-as.POSIXct(gdat$Date,format="%H:%M:%S %d-%b-%Y",tz="Etc/GMT+3")

#get data files
f<-list.files("C:/Users/Ben/Dropbox/Whales/Data/Humpback/",pattern="Behavior",full.names=T,recursive = T)
  dat<-bind_rows(lapply(f,read.csv))
  dat$GMTtime<-as.POSIXct(dat$End,format="%H:%M:%S %d-%b-%Y",tz="Etc/GMT+3")
  
#local time
dat$timestamp<-as.POSIXct(format(dat$GMTtime,tz="Etc/GMT+3"))

dat$Month<-months(dat$timestamp)
dat$Month<-factor(dat$Month,levels=month.name)
dat$Hour<-strftime(dat$timestamp,format="%H")
dat$Year<-years(dat$timestamp)
  
#create unique messages
indices<-which(dat$What=="Message")
counter=1
dat$ID<-NA
for (x in 1:(length(indices)-1)){
dat[indices[x]:indices[x+1],"ID"]<-counter
counter=counter+1
}

dive<-dat %>% filter(What=="Dive")%>% dplyr::select(Animal=Ptt,timestamp,Hour,Month,Year, ID,Start,DepthMax,DepthMin,DurationMax)
dive<-dive[!is.na(dive$Month),]
    
#remove duplicate data
dive<-dive %>% arrange(Animal,timestamp) 
dive<-dive[!duplicated(dive),]
```

```{r}
##Merge with geographic data and format for JAGS
messages<-dat %>% filter(dat$What=="Message")
messages$timestamp<-as.POSIXct(messages$End,format="%H:%M:%S %d-%b-%Y",tz="Etc/GMT+3")

#look up the time interval that best fits
setDT(gdat)            ## convert to data.table by reference
setDT(messages)            ## same

setkey(messages, Ptt,timestamp)    ## set the column to perform the join on
setkey(gdat,Ptt, Date)    ## same as above

ans = gdat[messages, roll=Inf] ## perform rolling join
ans<-as.data.frame(ans)

message_join<-ans %>% select(Date,Animal=Ptt,Date,Quality,Latitude,Longitude,ID)

mdat<-merge(dat,message_join,by="ID")
mdat<-mdat %>% filter(What=="Dive")

#The maxiumum dive depth based on the geographic message
mdat<-mdat %>% select(ID,Animal,Latitude,Longitude,timestamp,Date,Month,Hour,Year,DepthMax,Quality) 

mdat<-mdat %>% group_by(ID,Animal) %>% slice(which.max(DepthMax)) %>% arrange(Animal,timestamp) %>% filter(!is.na(Latitude))

#crop by extent
d<-SpatialPointsDataFrame(cbind(mdat$Longitude,mdat$Latitude),data=data.frame(mdat),proj4string=CRS("+proj=longlat +datum=WGS84"))

cropoly<-readShapePoly("Data/CutPolygon.shp",proj4string=CRS("+proj=longlat +datum=WGS84"))

b<-d[!is.na(d %over% cropoly)[,2],]

mdat<-b@data

#view data
ggplot(data=mdat)+geom_path(aes(x=Longitude, y=Latitude,group=Animal),size=.5) + geom_point(aes(x=Longitude, y=Latitude,col=DepthMax))+ borders(fill="grey90") + coord_cartesian(ylim = range(mdat$Latitude),xlim=range(mdat$Longitude)) + theme_bw() + mytheme + scale_color_continuous(low="blue",high="red") + labs(col="Max Dive Depth(m)")

##Time is the beginning of the first point.
step_length=6

sxy<-split(mdat,mdat$Animal)

#time diff function
timed<-function(d,step_length){
  d$j[1]<-0
  for (x in 2:nrow(d)){
    d$j[x]<-as.numeric(difftime(as.POSIXct(d$timestamp[x]),as.POSIXct(d$timestamp[x-1]),units="mins"))/(step_length*60)
  }
  
  #Split out track endings
  ends<-c(1,which(d$j>1),nrow(d))

  for(w in 2:length(ends)){
    d[ends[w-1]:ends[w],"Track"]<-w-1
  }
  
  #remove tracks that are shorter than three days
  track_time<-d %>% group_by(Track) %>% summarize(mt=difftime(max(as.POSIXct(timestamp)),min(as.POSIXct(timestamp)),units="hours")) %>% filter(mt>=24) %>% .$Track
  
  d<-d[d$Track %in% track_time,]
  
  #renumber the tracks
  d$Track<-as.numeric(as.factor(d$Track))
  return(d)
  }

sxy<-lapply(sxy,timed,step_length=step_length)

#Format matrices for jags
mdat<-bind_rows(sxy)

sxy<-split(mdat,list(mdat$Animal,mdat$Track),drop=TRUE)

sxy<-lapply(sxy,function(x){
#How many observations in each step length segment
x$step<-as.numeric(cut(as.POSIXct(x$timestamp),paste(step_length,"hours")))
return(x)
})

mdat<-bind_rows(sxy)

###################################################
#filter by two whales for the moment
mdat<-mdat %>% filter(Animal %in% c("131127","131136"))
####################################################

#refactor animal
mdat$Animal<-as.numeric(as.factor(mdat$Animal))

##Split into format for JAGS

#total number of steps per track/animal
steps_all<-mdat %>% group_by(Animal,Track) %>% summarize(n=length(unique(step)))

# give each step a label
mdat<-mdat %>% group_by(Animal,Track,step) %>% mutate(jStep=1:n())

#Cast time array
j<-reshape2::acast(mdat,Animal~Track~step~jStep,value.var="j")

#how many observations per individual in each step
mdat$step<-factor(mdat$step,levels=1:max(steps_all$n))
idx<-reshape2::melt(table(mdat$Animal,mdat$Track,mdat$step))
colnames(idx)<-c("Animal","Track","step","jStep")
idx<-reshape2::acast(data=idx,Animal~Track~step)

#Individuals
ind=length(unique(mdat$Animal))

#tracks per indivudal
tracks<-mdat %>% group_by(Animal) %>% summarize(tracks=length(unique(Track))) %>% .$tracks

#steps per track
steps<-reshape2::acast(steps_all,Animal~Track,value.var="n")

#obs array
obs<-reshape2::melt(mdat,measure.vars=c("Longitude","Latitude"))
obs<-reshape2::acast(obs,Animal~Track~step~jStep~variable,fun.aggregate = mean)

#argos class array
mdat$argos.lc<-factor(mdat$Quality,levels=c(3,2,1,0,"A","B"))
mdat$numargos<-as.numeric(mdat$argos.lc)
obs_class<-reshape2::acast(mdat,Animal~Track~step~jStep,value.var="numargos",fun.aggregate = min)

obs_class[!is.finite(obs_class)]<-NA

#average dive depth array
maxdive<-reshape2::acast(mdat,Animal~Track~step~jStep,value.var="DepthMax",fun.aggregate = mean)

#fill the empty values
maxdive[!is.finite(maxdive)]<-NA

#average number of dives
divecount<-reshape2::acast(mdat,Animal~Track~step,value.var="DepthMax",fun.aggregate = length)

#no dives, fill empty
divecount[divecount==0]<-NA

```

```{r,child="Bayesian/Diving.R",eval=T}
```

```{r,eval=T}
#source jags file
source("Bayesian/Diving.R")

#prior cov shape
R <- diag(c(1,1))
data=list(divecount=divecount,dive=maxdive,argos=obs,steps=steps,R=R,ind=ind,j=j,idx=idx,tracks=tracks,argos_class=obs_class)

#paramters to track
pt<-c("alpha","depth_mu","depth_tau","dive_new","state","lambda")

if(newModel){
  system.time(diving<-jags.parallel(model.file = "Bayesian/Diving.jags",data=data,n.chains=2,parameters.to.save=pt,n.iter=10000,n.burnin=9500,n.thin=2,DIC=FALSE))
}

```

##Chains
```{r,eval=T}
#bind chains
pc_dive<-reshape2::melt(diving$BUGSoutput$sims.array)
colnames(pc_dive)<-c("Draw","chain","par","value")

#extract parameter name
pc_dive$parameter<-data.frame(str_match(pc_dive$par,"(\\w+)"))[,-1]

#Extract index
splitpc<-split(pc_dive,pc_dive$parameter)

#single index
splitpc[c("alpha","depth_mu","depth_tau","lambda")]<-lapply(splitpc[c("alpha","depth_mu","depth_tau","lambda")],function(x){
    sv<-data.frame(str_match(x$par,"(\\w+)\\[(\\d+)]"))[,3]
    pc<-data.frame(x,Behavior=sv)
    return(pc)
}) 

#3 index
splitpc[c("state")]<-lapply(splitpc[c("state")],function(x){
    sv<-data.frame(str_match(x$par,"(\\w+)\\[(\\d+),(\\d+),(\\d+)"))[,3:5]
    colnames(sv)<-c("Animal","Track","step")
    pc<-data.frame(x,sv)
    return(pc)
}) 

#4 index
splitpc[c("dive_new")]<-lapply(splitpc[c("dive_new")],function(x){
    sv<-data.frame(str_match(x$par,"(\\w+)\\[(\\d+),(\\d+),(\\d+),(\\d+)]"))[,3:6]
    colnames(sv)<-c("Animal","Track","step","jStep")
    pc<-data.frame(x,sv)
    return(pc)
}) 
#bind all matrices back together
pc_dive<-bind_rows(splitpc)
rm(splitpc)

ggplot(pc_dive[!pc_dive$parameter %in% c("dive_new","state"),],aes(x=Draw,y=value,col=as.factor(chain))) + geom_line() + facet_wrap(~par,scales="free")

```

## Empirical distribution of foraging 

```{r}
alpha<-pc_dive %>% filter(parameter=="alpha")
alpha$Behavior<-as.character(alpha$Behavior)
alpha$Behavior[alpha$Behavior=="1"]<-"Traveling->Traveling"
alpha$Behavior[alpha$Behavior=="2"]<-"Foraging->Traveling"

ggplot(alpha,aes(x=value)) + geom_histogram() + facet_wrap(~Behavior) + labs(x="Probability of Transition")

#label previous and prediction state, treat traveling as a success and foraging as a failure in a binomial trial
alpha[alpha$Behavior=="Traveling->Traveling","Previous_State"]<-1
alpha[alpha$Behavior=="Foraging->Traveling","Previous_State"]<-0
```

### Time foraging as a function of time

* 12 time step

```{r}
foraging_time<-function(alpha,draws,step){
  states<-c()
  
  #initial state is traveling
  states[1]<-(1)
  
  for(x in 2:draws){
    
    #probability of staying, or switching, to traveling state
    travel_prob=alpha %>% filter(Previous_State==states[x-1]) %>% sample_n(1) %>% .$value
    
    #pick next state
    states[x]<-rbinom(1,1,travel_prob)
  }
  
  #total hours of foraging
  total_foraging<-sum(states==0) * step
return(total_foraging)
}

states<-foraging_time(alpha=alpha,draw=20,step=12)
```

This allows us to specify the hours foraging while capturing our uncertainty in behavioral states

For example, if we wanted to know how many hours an animal was predicted to forage on average over a 10 day span. We can draw 100 simulations given the posterior distributions of our empirical model.

```{r}

test_time<-sapply(1:1000,function(x){
  foraging_time(alpha=alpha,draw=20,step=12)
})
paste("Mean foraging hours:", mean(test_time),sep=" ")

qplot(test_time) +ggtitle("Foraging Time (10 Days)") +xlab("Hours")
```


##Distribution of average max dive depths

```{r}
divep<-pc_dive %>% filter(parameter %in% c("depth_mu","depth_tau"))

## Simulate dive depth
depth_mu1<-pc_dive %>% filter(parameter %in% c("depth_mu"),Behavior==1)
depth_mu2<-pc_dive %>% filter(parameter %in% c("depth_mu"),Behavior==2)
depth_tau1<-pc_dive %>% filter(parameter %in% c("depth_tau"),Behavior==1)
depth_tau2<-pc_dive %>% filter(parameter %in% c("depth_tau"),Behavior==2)

#how many of each state to draw?
statecount<-pc_dive %>% filter(parameter=="state") %>% group_by(Animal,Track,step) %>% summarize(state=names(sort(table(value)))[1]) %>% group_by(state) %>% summarize(n=n()) %>% data.frame()

travel_dives<-data.frame(MaxDepth=rnorm(statecount[1,"n"],depth_mu1$value,sqrt(1/depth_tau1$value)),Behavior="Traveling")
forage_dives<-data.frame(MaxDepth=rnorm(statecount[2,"n"],depth_mu2$value,sqrt(1/depth_tau2$value)),Behavior="Foraging")
pred_dives<-bind_rows(travel_dives,forage_dives)
ggplot(pred_dives) + geom_density(alpha=0.5,aes(x=MaxDepth,fill=Behavior)) + geom_density(data=mdat,aes(x=DepthMax),col="black",size=1) + theme_bw() 

ggplot(pc_dive[pc_dive$parameter=="dive_new",])+  geom_density(aes(x=value),col="red") + geom_density(data=mdat,aes(x=DepthMax),col="black",size=1.5) + theme_bw() 
```

##Distribution of average dive counts

```{r}

## Simulate dive counts
count_lambda1<-pc_dive %>% filter(parameter %in% c("lambda"),Behavior==1)
count_lambda2<-pc_dive %>% filter(parameter %in% c("lambda"),Behavior==2)

statecount<-pc_dive %>% filter(parameter=="state") %>% group_by(Animal,Track,step) %>% summarize(state=names(sort(table(value)))[1]) %>% group_by(state) %>% summarize(n=n()) %>% data.frame()

travel_counts<-data.frame(Counts=rpois(statecount[1,"n"],count_lambda1$value),Behavior="Traveling")
forage_counts<-data.frame(Counts=rpois(statecount[2,"n"],count_lambda2$value),Behavior="Foraging")

#calculate observed
obs_count<-mdat %>% group_by(Animal,Track,step) %>% summarize(Counts=n())

pred_counts<-bind_rows(travel_counts,forage_counts)
ggplot(pred_counts) + geom_density(alpha=0.5,aes(x=Counts,fill=Behavior)) + geom_density(data=obs_count,aes(x=Counts),col="black",size=1) + theme_bw() 
```

## Posterior checks

* Compare observed dive depths by inferred behavior against generated data

```{r,eval=F}
pred_dives<-pc_dive %>% filter(parameter=="dive_new") %>% group_by(Animal,Track,step,jStep) %>% summarize(Pred_DepthMax=mean(value)) %>% ungroup()  %>% mutate(Animal=as.numeric(as.character(Animal)),Track=as.numeric(as.character(Track)),jStep=as.numeric(as.character(jStep)))

predframe<-pred_dives %>% inner_join(mdat,by=c("Animal","Track","step","jStep")) %>% select(Animal,Latitude,Longitude,Track,step,jStep,timestamp,Predicted=Pred_DepthMax,Observed=DepthMax)

#merge with state
predframe<-pc_dive %>% filter(parameter=="state") %>% group_by(Animal,Track,step) %>% summarize(state=names(sort(table(value)))[1]) %>% ungroup()  %>% mutate(Animal=as.numeric(as.character(Animal)),Track=as.numeric(as.character(Track))) %>% inner_join(predframe,by=c("Animal","Track","step"))

predframe<-reshape2::melt(predframe, measure.vars=c("Predicted","Observed"),value.name="DepthMax")

ggplot(data=predframe) + geom_histogram(aes(x=DepthMax,fill=variable),alpha=0.8)  + theme_bw()

ggplot(data=predframe) + geom_density(aes(x=DepthMax,fill=variable),alpha=0.8) 

ggplot(data=predframe) + geom_density(aes(x=DepthMax,fill=variable),alpha=0.8) + facet_wrap(~state) + ggtitle("By Behavior")

ggplot(data=predframe) + geom_density(aes(x=DepthMax,fill=variable),alpha=0.8) + facet_wrap(~Animal) + ggtitle("By Animal")

```

```{r}
save.image("WhalePhys.RData")
```
