---
title: "Foraging Model"
author: "Ben Weinstein"
date: "`r Sys.time()`"
output: 
  html_document:
    toc: true
    number_sections: true
    theme: united
---


# Foraging Model

The proportion of time an animal is in a feeding behavioral state.

(@eq1)

*Process Model*

$$Y_{i,t+1} \sim Multivariate Normal(d_{i,t},σ)$$

$$d_{i,t}= Y_{i,t} + γ_{s_{i,g,t}}*T_{i,g,t}*( Y_{i,g,t}- Y_{i,g,t-1} )$$

$$
\begin{matrix}
  \alpha_{i,1,1} & 1-\alpha_{i,1,1} \\
  \alpha_{i,2,1} & 1-\alpha_{i,2,1} \\
\end{matrix}
$$
$$logit(\phi_{traveling}) = \alpha_{Behavior_{t-1}} $$
The behavior at time t of individual i on track g is a discrete draw.
$$S_{i,g,t} \sim Cat(\phi_{traveling},\phi_{foraging})$$

Dive information is a mixture model based on behavior (S)

$\text{Average dive depth}(\psi)$
$$ \psi \sim Normal(dive_{\mu_S},dive_{\tau_S})$$

```{r,echo=F,warning=F,message=F}
library(tidyr)
library(ggplot2)
library(maptools)
library(raster)
library(data.table)

library(dplyr)
library(stringr)
library(chron)
library(R2jags)
library(boot)
library(knitr)
library(truncnorm)

newModel=T

opts_chunk$set(echo=F,warning=F,message=F,fig.width=11)

mytheme<-theme(axis.text.x=element_blank(),axis.ticks.x=element_blank(),axis.text.y=element_blank(),axis.ticks.y=element_blank(),axis.title.x=element_blank(),axis.title.y=element_blank(),panel.grid=element_blank())
```

```{r}
if(!newModel){
  load("/Users/Ben/Dropbox/Whales/Dive/WhalePhys.RData")
  newModel=F
}

#get gps data
f<-list.files("/Users/Ben/Dropbox/Whales/Data/Humpback",pattern="Locations",full.names=T,recursive = T)

#just grab five individuals for now
gdat<-lapply(f,function(x) read.csv(x,stringsAsFactors=F))
gdat<-lapply(gdat,function(x){
  x$Quality<-as.character(x$Quality)
  return(x)
}) 

gdat<-bind_rows(gdat)

#timestamp
gdat$Date<-as.POSIXct(gdat$Date,format="%H:%M:%S %d-%b-%Y",tz="Etc/GMT+3")

#get dive data files
f<-list.files("/Users/Ben/Dropbox/Whales/Data/Humpback/",pattern="Behavior",full.names=T,recursive = T)
dat<-bind_rows(lapply(f,read.csv))

dat$GMTtime<-as.POSIXct(dat$End,format="%H:%M:%S %d-%b-%Y",tz="GMT")
  
#local time
dat$timestamp<-as.POSIXct(format(dat$GMTtime,tz="Etc/GMT+3"))

dat$Month<-months(dat$timestamp)
dat$Month<-factor(dat$Month,levels=month.name)
dat$Hour<-strftime(dat$timestamp,format="%H")
dat$Year<-years(dat$timestamp)
  
#create unique messages
indices<-which(dat$What=="Message")
counter=1
dat$ID<-NA
for (x in 1:(length(indices)-1)){
dat[indices[x]:indices[x+1],"ID"]<-counter
counter=counter+1
}

dive<-dat %>% filter(What=="Dive")%>% dplyr::select(Animal=Ptt,timestamp,Hour,Month,Year, ID,Start,DepthMax,DepthMin,DurationMax,DurationMin)
dive<-dive[!is.na(dive$Month),]
    
#remove duplicate data
dive<-dive %>% arrange(Animal,timestamp) 
dive<-dive[!duplicated(dive),]

dive %>% group_by(Animal,Year) %>% summarize(n=n())
```

Dive profiles per indidivuals

```{r}
ggplot(dive[,],aes(x=timestamp,y=-DepthMax)) + geom_point(size=0.1) + geom_line(size=0.1) + facet_wrap(~Animal,scales="free") + theme_bw()
ggsave("Figures/perindividual.jpeg",height=6,width=12)
```


```{r}
##Merge with geographic data and format for JAGS
messages<-dat %>% filter(dat$What=="Message")
messages$timestamp<-as.POSIXct(messages$End,format="%H:%M:%S %d-%b-%Y",tz="Etc/GMT+3")

#look up the time interval that best fits
setDT(gdat)            ## convert to data.table by reference
setDT(messages)            ## same

setkey(messages, Ptt,timestamp)    ## set the column to perform the join on
setkey(gdat,Ptt, Date)    ## same as above

ans = gdat[messages, roll=Inf] ## perform rolling join
ans<-as.data.frame(ans)

message_join<-ans %>% dplyr::select(Date,Animal=Ptt,Date,Quality,Latitude,Longitude,ID)

mdat<-merge(dat,message_join,by="ID")
mdat<-mdat %>% filter(What=="Dive")

#The maxiumum dive depth based on the geographic message
mdat<-mdat %>% dplyr::select(ID,Animal,Latitude,Longitude,timestamp,Date,Month,Hour,Year,DepthMax,DurationMax,DurationMin,Quality) 

mdat<-mdat %>% group_by(ID,Animal) %>% slice(which.max(DepthMax)) %>% arrange(Animal,timestamp) %>% filter(!is.na(Latitude))

#crop by extent
d<-SpatialPointsDataFrame(cbind(mdat$Longitude,mdat$Latitude),data=data.frame(mdat),proj4string=CRS("+proj=longlat +datum=WGS84"))

cropoly<-readShapePoly("Data/CutPolygon.shp",proj4string=CRS("+proj=longlat +datum=WGS84"))

b<-d[!is.na(d %over% cropoly)[,2],]

mdat<-b@data
```

Data Statistics before track cut

```{r}
mdat %>% group_by(Animal) %>% summarize(n=n())
nrow(mdat)
```


```{r}
#set max depth to km
mdat$DepthMax<-mdat$DepthMax/1000

#set duration to minutes
mdat$DurationMax<-mdat$DurationMax/60

mdat<-mdat %>% filter(DurationMax<20)

#view data
ggplot(data=mdat)+geom_path(aes(x=Longitude, y=Latitude,group=Animal),size=.5) + geom_point(aes(x=Longitude, y=Latitude,col=DepthMax))+ borders(fill="grey90") + coord_cartesian(ylim = range(mdat$Latitude),xlim=range(mdat$Longitude)) + theme_bw() + mytheme + scale_color_continuous(low="blue",high="red") + labs(col="Max Dive Depth (km)")
ggsave("Figures/Map.svg")
ggsave("Figures/Map.png")

##Time is the beginning of the first point.
step_length=6

sxy<-split(mdat,mdat$Animal)

#time diff function
timed<-function(d,step_length){
  d$j[1]<-0
  for (x in 2:nrow(d)){
    d$j[x]<-as.numeric(difftime(as.POSIXct(d$timestamp[x]),as.POSIXct(d$timestamp[x-1]),units="mins"))/(step_length*60)
  }
  
  #Split out track endings
  ends<-c(1,which(d$j>1),nrow(d))

  for(w in 2:length(ends)){
    d[ends[w-1]:ends[w],"Track"]<-w-1
  }
  
  #remove tracks that are shorter than 1 days
  track_time<-d %>% group_by(Track) %>% summarize(mt=difftime(max(as.POSIXct(timestamp)),min(as.POSIXct(timestamp)),units="hours")) %>% filter(mt>=24) %>% .$Track
  
  d<-d[d$Track %in% track_time,]
  
  #renumber the tracks
  d$Track<-as.numeric(as.factor(d$Track))
  return(d)
  }

sxy<-lapply(sxy,timed,step_length=step_length)

#Format matrices for jags
mdat<-bind_rows(sxy)

sxy<-split(mdat,list(mdat$Animal,mdat$Track),drop=TRUE)

sxy<-lapply(sxy,function(x){
#How many observations in each step length segment
x$step<-as.numeric(cut(as.POSIXct(x$timestamp),paste(step_length,"hours")))
return(x)
})

mdat<-bind_rows(sxy)
```

Data statistics after track cut
```{r}
mdat %>% group_by(Animal) %>% summarize(n=n())
```

```{r}
###################################################
#filter by two whales for the moment
#mdat<-mdat %>% filter(Animal %in% c("131127","131136","131132","131133","154187","131134","131115","131111","131130","131136"))
#mdat<-mdat %>% filter(Animal %in% c("131127"))
####################################################

#refactor animal
mdat$Animal<-as.numeric(as.factor(mdat$Animal))

##Split into format for JAGS

#total number of steps per track/animal
steps_all<-mdat %>% group_by(Animal,Track) %>% summarize(n=length(unique(step)))

# give each step a label
mdat<-mdat %>% group_by(Animal,Track,step) %>% mutate(jStep=1:n())

#Cast time array
j<-reshape2::acast(mdat,Animal~Track~step~jStep,value.var="j")

#how many observations per individual in each step
mdat$step<-factor(mdat$step,levels=1:max(steps_all$n))
idx<-reshape2::melt(table(mdat$Animal,mdat$Track,mdat$step))
colnames(idx)<-c("Animal","Track","step","jStep")
idx<-reshape2::acast(data=idx,Animal~Track~step)

#Individuals
ind=length(unique(mdat$Animal))

#tracks per indivudal
tracks<-mdat %>% group_by(Animal) %>% summarize(tracks=length(unique(Track))) %>% .$tracks

#steps per track
steps<-reshape2::acast(steps_all,Animal~Track,value.var="n")

#obs array
obs<-reshape2::melt(mdat,measure.vars=c("Longitude","Latitude"))
obs<-reshape2::acast(obs,Animal~Track~step~jStep~variable,fun.aggregate = mean)

#argos class array
mdat$argos.lc<-factor(mdat$Quality,levels=c(3,2,1,0,"A","B"))
mdat$numargos<-as.numeric(mdat$argos.lc)
obs_class<-reshape2::acast(mdat,Animal~Track~step~jStep,value.var="numargos",fun.aggregate = min)

obs_class[!is.finite(obs_class)]<-NA

#average dive depth array
maxdive<-reshape2::acast(mdat,Animal~Track~step~jStep,value.var="DepthMax",fun.aggregate = mean)

#fill the empty values
maxdive[!is.finite(maxdive)]<-NA

#average number of dives
diveduration<-reshape2::acast(mdat,Animal~Track~step~jStep,value.var="DurationMax")
```

```{r,child="Bayesian/Diving.R",eval=T}
```

```{r,eval=T}
#source jags file
source("Bayesian/Diving.R")

#prior cov shape
R <- diag(c(1,1))
data=list(duration=diveduration,dive=maxdive,argos=obs,steps=steps,R=R,ind=ind,j=j,idx=idx,tracks=tracks,argos_class=obs_class)

#paramters to track
pt<-c("alpha","gamma","duration_mu","duration_tau","depth_mu","depth_tau","dive_new","state","E","Enew")

if(newModel){
  system.time(diving<-jags.parallel(model.file = "Bayesian/Diving.jags",data=data,n.chains=2,parameters.to.save=pt,n.iter=55000,n.burnin=54500,n.thin=2,DIC=FALSE))
  }

```

##Chains
```{r,eval=T}
#bind chains
pc_dive<-reshape2::melt(diving$BUGSoutput$sims.array)
colnames(pc_dive)<-c("Draw","chain","par","value")

#extract parameter name
pc_dive$parameter<-data.frame(str_match(pc_dive$par,"(\\w+)"))[,-1]

#Extract index
splitpc<-split(pc_dive,pc_dive$parameter)

#single index
splitpc[c("alpha","depth_mu","depth_tau","duration_mu","duration_tau")]<-lapply(splitpc[c("alpha","depth_mu","depth_tau","duration_mu","duration_tau")],function(x){
    sv<-data.frame(str_match(x$par,"(\\w+)\\[(\\d+)]"))[,3]
    pc<-data.frame(x,Behavior=sv)
    return(pc)
}) 


#3 index
splitpc[c("state")]<-lapply(splitpc[c("state")],function(x){
    sv<-data.frame(str_match(x$par,"(\\w+)\\[(\\d+),(\\d+),(\\d+)"))[,3:5]
    colnames(sv)<-c("Animal","Track","step")
    pc<-data.frame(x,sv)
    return(pc)
}) 

#4 index
splitpc[c("dive_new","E","Enew")]<-lapply(splitpc[c("dive_new","E","Enew")],function(x){
    sv<-data.frame(str_match(x$par,"(\\w+)\\[(\\d+),(\\d+),(\\d+),(\\d+)]"))[,3:6]
    colnames(sv)<-c("Animal","Track","step","jStep")
    pc<-data.frame(x,sv)
    return(pc)
}) 
#bind all matrices back together
pc_dive<-bind_rows(splitpc)
rm(splitpc)

ggplot(pc_dive[!pc_dive$parameter %in% c("dive_new","state","E","Enew","eval"),],aes(x=Draw,y=value,col=as.factor(chain))) + geom_line() + facet_wrap(~par,scales="free")
ggplot(pc_dive[!pc_dive$parameter %in% c("dive_new","state","E","Enew","eval"),],aes(x=value,fill=as.factor(chain))) + geom_histogram() + facet_wrap(~par,scales="free")

```

## Temporal autocorrelation in foraging 

```{r,eval=F}
alpha<-pc_dive %>% filter(parameter=="alpha")
alpha$Behavior<-as.character(alpha$Behavior)
alpha$Behavior[alpha$Behavior=="1"]<-"Traveling->Traveling"
alpha$Behavior[alpha$Behavior=="2"]<-"Foraging->Traveling"

ggplot(alpha,aes(x=inv.logit(value))) + geom_histogram() + facet_wrap(~Behavior) + labs(x="Probability of Transition")

#label previous and prediction state, treat traveling as a success and foraging as a failure in a binomial trial
alpha[alpha$Behavior=="Traveling->Traveling","Previous_State"]<-1
alpha[alpha$Behavior=="Foraging->Traveling","Previous_State"]<-0
write.csv(alpha,"Data/Alpha.csv",row.names=F)
```

### Time foraging as a function of time

```{r,eval=F}
foraging_time<-function(alpha,draws,step){
  states<-c()
  
  #initial state is traveling
  states[1]<-(1)
  
  for(x in 2:draws){
    
    #probability of staying, or switching, to traveling state
    travel_prob=alpha %>% filter(Previous_State==states[x-1]) %>% sample_n(1) %>% .$value
    
    #pick next state
    states[x]<-rbinom(1,1,travel_prob)
  }
  
  #total hours of foraging
  total_foraging<-sum(states==0) * step
return(total_foraging)
}

states<-foraging_time(alpha=alpha,draw=20,step=12)

```

## Simulate dive depth
```{r}
depth_mu1<-pc_dive %>% filter(parameter %in% c("depth_mu"),Behavior==1)
depth_mu2<-pc_dive %>% filter(parameter %in% c("depth_mu"),Behavior==2)
depth_tau1<-pc_dive %>% filter(parameter %in% c("depth_tau"),Behavior==1)
depth_tau2<-pc_dive %>% filter(parameter %in% c("depth_tau"),Behavior==2)

#how many of each state to draw?
statecount<-pc_dive %>% filter(parameter=="state") %>% group_by(Animal,Track,step) %>% summarize(state=names(sort(table(value)))[1]) %>% ungroup() %>% mutate(Animal=as.numeric(as.character(Animal)),Track=as.numeric(as.character(Track))) %>% inner_join(mdat,by=c("Animal","Track","step")) %>% group_by(state) %>% summarize(n=n()) %>% data.frame()

#simulate dives 
travel_dives<-data.frame(MaxDepth=rtruncnorm(statecount[1,"n"], mean=depth_mu1$value,sd=sqrt(1/depth_tau1$value),a=0),Behavior="Traveling")
forage_dives<-data.frame(MaxDepth=rtruncnorm(statecount[2,"n"], mean=depth_mu2$value,sd=sqrt(1/depth_tau2$value),a=0),Behavior="Foraging")
pred_dives<-bind_rows(travel_dives,forage_dives)

ggplot(pred_dives)  + geom_histogram(data=mdat,aes(x=DepthMax*1000),col="black")+ geom_histogram(alpha=0.8,aes(x=MaxDepth*1000,fill=Behavior))  + theme_bw() + labs(x="Dive Depth (m)")
ggsave("Figures/DiveHist.jpg",height=4,width=7)

ggplot(pc_dive[pc_dive$parameter=="dive_new",])+  geom_density(aes(x=value*1000),col='red') + geom_density(data=mdat,aes(x=DepthMax*1000),col="black",size=1.5) + theme_bw() + labs(x="Dive Depth (m)")
ggsave("Figures/DivePredict.jpg",height=4,width=7)
```

## Simulate dive durations

```{r,eval=T}
duration_mu1<-pc_dive %>% filter(parameter %in% c("duration_mu"),Behavior==1)
duration_mu2<-pc_dive %>% filter(parameter %in% c("duration_mu"),Behavior==2)
duration_tau1<-pc_dive %>% filter(parameter %in% c("duration_tau"),Behavior==1)
duration_tau2<-pc_dive %>% filter(parameter %in% c("duration_tau"),Behavior==2)

#how many of each state to draw?
statecount<-pc_dive %>% filter(parameter=="state") %>% group_by(Animal,Track,step) %>% summarize(state=names(sort(table(value)))[1]) %>% ungroup() %>% mutate(Animal=as.numeric(as.character(Animal)),Track=as.numeric(as.character(Track))) %>% inner_join(mdat,by=c("Animal","Track","step")) %>% group_by(state) %>% summarize(n=n()) %>% data.frame()

#simulate dives 
travel_dives<-data.frame(DurationMax=rtruncnorm(statecount[1,"n"], mean=duration_mu1$value,sd=sqrt(1/duration_tau1$value),a=0),Behavior="Traveling")
forage_dives<-data.frame(DurationMax=rtruncnorm(statecount[2,"n"], mean=duration_mu2$value,sd=sqrt(1/duration_tau1$value),a=0),Behavior="Foraging")
pred_dives<-bind_rows(travel_dives,forage_dives)

ggplot(pred_dives)  + geom_histogram(data=mdat,aes(x=DurationMax),col="black")+ geom_histogram(alpha=0.8,aes(x=DurationMax,fill=Behavior))  + theme_bw() 
ggsave("Figures/DurationHist.jpg",height=5,width=7)

ggplot(pred_dives)  + geom_density(data=mdat,aes(x=DurationMax),col="black")+ geom_histogram(alpha=0.8,aes(x=DurationMax,fill=Behavior))  + theme_bw() 

ggplot(pred_dives)+  geom_density(aes(x=DurationMax),col='red') + geom_density(data=mdat,aes(x=DurationMax),col="black",size=1.5) + theme_bw() + labs(x="Dive Depth (m)")
ggsave("Figures/DurationPred.jpg",height=5,width=7)

```

# Temporal Variation in Dive Behavior

```{r}

#Take the most common estimate of behavior
Mode <- function(x) {
  ux <- unique(x)
  ux[which.max(tabulate(match(x, ux)))]
}

#Combine posterior summary
mdat$Animal<-as.factor(mdat$Animal)
mdat$Track<-as.factor(mdat$Track)
mdat$step<-as.factor(mdat$step)

state_est<-pc_dive %>% group_by(Animal,Track,step) %>% filter(parameter=="state") %>% summarize(Behavior=Mode(value)) %>% inner_join(mdat)

state_est[state_est$Behavior==1,"Behavior"]<-"Traveling"
state_est[state_est$Behavior==2,"Behavior"]<-"Foraging"
```

```{r,fig.height=15,fig.width=12}
ggplot(state_est,aes(x=timestamp,y=-DepthMax,col=Behavior)) + geom_point() + geom_line(size=0.25,aes(group=1)) + facet_wrap(~Animal,scales="free",ncol=1) + theme_bw()
ggsave("Figures/TemporalBehavior.svg")
ggsave("Figures/TemporalBehavior.jpeg",height=8,width=12)

#Look at time interval
#ggplot(state_est,aes(x=timestamp,y=-DepthMax,col=step)) + geom_point() + geom_line(size=0.25,aes(group=1)) + facet_wrap(~Animal,scales="free",ncol=1) + theme_bw()

by_state<-state_est %>% group_by(Animal,Track,step) %>% summarize(timestamp=min(timestamp),dive=mean(DepthMax),Behavior=unique(Behavior))
ggplot(by_state,aes(x=timestamp,y=-dive,col=Behavior)) + geom_point() + geom_line(size=0.25,aes(group=1)) + facet_wrap(~Animal,scales="free",ncol=1) + theme_bw()
```

## Diel

```{r}
ggplot(data=state_est) + geom_boxplot(aes(x=Hour,y=DepthMax,fill=Behavior)) + ylab("Maximum Dive Depth (km)")
ggsave("Figures/Diel.svg")
ggsave("Figures/Diel.png",height=5,width=8,unit="in")

ggplot(data=state_est) + geom_boxplot(aes(x=Hour,y=DepthMax,fill=Behavior)) + ylab("Maximum Dive Depth (km)") + facet_wrap(~Month)
ggsave("Figures/DielbyMonth.svg")
ggsave("Figures/DielbyMonth.png",height=5,width=10,unit="in")
```

## Month
```{r}
ggplot(data=state_est) + geom_boxplot(aes(x=Month,y=DepthMax,fill=Behavior)) + ylab("Maximum Dive Depth (km)")
ggsave("Figures/Month.svg")
ggsave("Figures/Month.png",height=5,width=8,unit="in")
```

```{r}
ggplot(data=state_est)+geom_path(aes(x=Longitude, y=Latitude,group=paste(Animal,Track)),size=0.5) + geom_point(aes(x=Longitude, y=Latitude,col=Behavior),size=0.5)+ borders(fill="grey90") + coord_cartesian(ylim = range(mdat$Latitude),xlim=range(mdat$Longitude)) + theme_bw() + mytheme 
```

# Comparison with 2d movement model

* Movement model

```{r,eval=T}
#source jags file
source("Bayesian/Foraging.R")

#prior cov shape
R <- diag(c(1,1))
data=list(argos=obs,steps=steps,R=R,ind=ind,j=j,idx=idx,tracks=tracks,argos_class=obs_class)

#paramters to track
pt<-c("alpha","gamma","state")

if(newModel){
  system.time(foraging<-jags.parallel(model.file = "Bayesian/Foraging.jags",data=data,n.chains=2,parameters.to.save=pt,n.iter=55000,n.burnin=54500,n.thin=2,DIC=FALSE))
  }

```

##Chains

```{r,eval=T}
#bind chains
pc_dive2d<-reshape2::melt(foraging$BUGSoutput$sims.array)
colnames(pc_dive2d)<-c("Draw","chain","par","value")

#extract parameter name
pc_dive2d$parameter<-data.frame(str_match(pc_dive2d$par,"(\\w+)"))[,-1]

#Extract index
splitpc<-split(pc_dive2d,pc_dive2d$parameter)

#single index
splitpc[c("alpha")]<-lapply(splitpc[c("alpha")],function(x){
    sv<-data.frame(str_match(x$par,"(\\w+)\\[(\\d+)]"))[,3]
    pc<-data.frame(x,Behavior=sv)
    return(pc)
}) 

#3 index
splitpc[c("state")]<-lapply(splitpc[c("state")],function(x){
    sv<-data.frame(str_match(x$par,"(\\w+)\\[(\\d+),(\\d+),(\\d+)"))[,3:5]
    colnames(sv)<-c("Animal","Track","step")
    pc<-data.frame(x,sv)
    return(pc)
}) 

#bind all matrices back together
pc_dive2d<-bind_rows(splitpc)
rm(splitpc)

ggplot(pc_dive2d[!pc_dive2d$parameter %in% c("state"),],aes(x=Draw,y=value,col=as.factor(chain))) + geom_line() + facet_wrap(~par,scales="free")
```

```{r}

#Take the most common estimate of behavior
Mode <- function(x) {
  ux <- unique(x)
  ux[which.max(tabulate(match(x, ux)))]
}

#Combine posterior summary
mdat$Animal<-as.factor(mdat$Animal)
mdat$Track<-as.factor(mdat$Track)
mdat$step<-as.factor(mdat$step)

state_est2d<-pc_dive2d %>% group_by(Animal,Track,step) %>% filter(parameter=="state") %>% summarize(Behavior =Mode(value)) %>% inner_join(mdat)

state_est2d[state_est2d$Behavior==1,"Behavior"]<-"Traveling"
state_est2d[state_est2d$Behavior==2,"Behavior"]<-"Foraging"

state_est$Model<-"3D"
state_est2d$Model<-"2D"

allmodels<-bind_rows(state_est,state_est2d)

```

```{r}
ggplot(data=allmodels)+geom_path(aes(x=Longitude, y=Latitude,group=paste(Animal,Track)),size=0.5) + geom_point(aes(x=Longitude, y=Latitude,col=Behavior),size=0.5)+ borders(fill="grey90") + coord_cartesian(ylim = range(mdat$Latitude),xlim=range(mdat$Longitude)) + theme_bw() + mytheme  + facet_wrap(~Model)
ggsave("Figures/SpatialPred.jpg",height=4,width=7)
```

Where does the 3d predict foraging that the 2d misses?

```{r}
allmodels<-spread(allmodels,Model,Behavior)
allmodels$Mismatch<-F
allmodels[allmodels$`2D`=="Traveling" & allmodels$`3D`=="Foraging","Mismatch"]<-TRUE

ggplot(allmodels)+geom_path(aes(x=Longitude, y=Latitude,group=paste(Animal,Track)),size=.25) + geom_point(aes(x=Longitude, y=Latitude,col=Mismatch))+ borders(fill="grey90") + coord_cartesian(ylim = range(mdat$Latitude),xlim=range(mdat$Longitude)) + theme_bw() + mytheme + scale_color_manual(values=c("Black","Red"))
ggsave("Figures/Mismatch1.jpg",height=4,width=7)
```

Where does the 2d predict foraging that the 3d refines?

```{r}
allmodels$Mismatch<-F
allmodels[allmodels$`2D`=="Foraging" & allmodels$`3D`=="Traveling","Mismatch"]<-TRUE

ggplot(allmodels)+geom_path(aes(x=Longitude, y=Latitude,group=paste(Animal,Track)),size=.25) + geom_point(aes(x=Longitude, y=Latitude,col=Mismatch))+ borders(fill="grey90") + coord_cartesian(ylim = range(mdat$Latitude),xlim=range(mdat$Longitude)) + theme_bw() + mytheme + scale_color_manual(values=c("Black","Red"))
ggsave("Figures/Mismatch2.jpg",height=4,width=7)
```

```{r,eval=F}
#time in each cell function
  timecell<-function(j){
    
    rlej<-rle(x=diff(j$Index))
    position<-c(1,cumsum(rlej$lengths))
    timestack<-c()
    
    #if only one position
    if(length(position)==1){
      timestack[1]<-0
      
    } else {
      
      #time difference between first and last point in the cell
        for(x in 2:length(position)){
          timed<-j[position[x-1]:position[x],]
          timestack[x-1]<-difftime(max(timed$timestamp),min(timed$timestamp),units="days")
      }
    }
  
    out<-data.frame(Sum=sum(timestack))
    return(out)
  }
  
restime<-function(mdat){
  #raster
  r<-raster(extent(d)*c(1.1,1.1),nrow=100,ncol=100)
  
  #res(r)<-0.25
  #put cellindex number
  r[]<-1:ncell(r)
  
  sxy<-split(mdat,mdat$Animal)
  sxy<-lapply(sxy,function(x) {x$Index<-1:nrow(x); return(x)})
  
  #loop through all animals
  sptracks<-lapply(sxy,function(x){
    k<-SpatialPointsDataFrame(cbind(x$x,x$y),data=x,proj4string=CRS("+proj=longlat +datum=WGS84"))
    
    #get the cells that points are in
    k$cellvalue<-raster::extract(x=r,y=k)
    
    #for each cell value, perform time function
    sptrack<-as.data.frame(k) %>% group_by(Animal,cellvalue) %>% do(timecell(.))
    return(sptrack)}
  )
  
  sptracks<-rbind_all(sptracks)
  
  #get sum across animals
  cellvals<-sptracks %>% group_by(cellvalue) %>% summarize(Sum=sum(Sum))
  
  #is there a better way to loop through?
  r[]<-NA
  for(x in 1:nrow(cellvals)){
    r[cellvals$cellvalue[x]]<-cellvals$Sum[x]
  }
  return(r)
}

plot(restime(mdat))

r<-stack(lapply(mdat,restime))

plot(r)

#turn to 
f<-melt(data.frame(rasterToPoints(r)),id.vars=c("Latitude","Longitude"))

#remove NA's
f<-f %>% filter(!is.na(value))

ggplot() + geom_tile(data=f,aes(x=Longitude,y=Latitude,fill=value))  + scale_fill_continuous(low="blue",high="red") + labs(fill="Days")  + facet_wrap(~variable,nrow=3)  + theme(axis.text.x=element_blank(),axis.text.y=element_blank(),axis.ticks.x=element_blank(),axis.ticks.y=element_blank()) + labs(x="",y="") +  borders(fill="grey70",size=0.5) + coord_cartesian(ylim = c(-69,-62),xlim=c(-55,-72)) + theme_bw() + mytheme
ggsave("Figures/ResidencyMap.jpg",height=9,width=6,dpi=300)
```

## Posterior Checks

The goodness of fit is a measured as chi-squared. The expected value is compared to the observed value of the actual data. In addition, a replicate dataset is generated from the posterior predicted intensity. Better fitting models will have lower discrepancy values and be 
Better fitting models are smaller values and closer to the 1:1 line. A perfect model would be 0 discrepancy. This is unrealsitic given the stochasticity in the sampling processes. Rather, its better to focus on relative discrepancy. In addition, a model with 0 discrepancy would likely be seriously overfit and have little to no predictive power.

```{r,fig.height=4,fig.width=8,message=F,warning=F}

fitstat<-pc_dive %>% filter(parameter %in% c("E","Enew")) %>% group_by(parameter,Draw,chain) %>% summarize(fit=mean(value))

fitstat<-dcast(fitstat,Draw+chain~parameter,value.var="fit")

ymin<-min(c(fitstat$E,fitstat$Enew)) - min(c(fitstat$E,fitstat$Enew)) * .1
ymax<-max(c(fitstat$E,fitstat$Enew)) + max(c(fitstat$E,fitstat$Enew)) * .1
ggplot(fitstat,aes(x=E,y=Enew)) + geom_point() + theme_bw() + labs(x="Discrepancy of observed data",y="Discrepancy of replicated data") + geom_abline() + coord_fixed() + ylim(ymin=ymin,ymax=ymax) + xlim(xmin=ymin,xmax=ymax)
ggsave("Figures/PosteriorCheck.jpg",height = 4,width = 4)
fitstat %>% group_by() %>% summarize(mean(E),var(Enew))
```

```{r}
save.image("/Users/Ben/Dropbox/Whales/Dive/WhalePhys.RData")
```